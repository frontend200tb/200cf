<article class="article">
  <strong>ТулГУ</strong>
  <p><a href="https://codeforces.com/group/kjV5ruxRwB/contests" target="_blank">Codeforces Тренировки выходного дня</a></p>
</article>


<article class="article">
  <h1>1 Группы Е,D,C Воскресная тренировка 2025.09.14</h1>
  <p><a href="https://codeforces.com/group/kjV5ruxRwB/contest/634575" target="_blank">Codeforces Контест 634575</a></p>
  <p>(личная, ioi)</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#t1">Задача A. Мойка автомобиля</a>
  <br><a href="#t2">Задача B. Настоящие друзья</a>
  <br><a href="#t3">Задача C. Пирамида</a>
  <br><a href="#t4">Задача D. Простой феникс</a>
  <br><a href="#t5">Задача E. Дело о делимости</a>
</article>


<!-- Задача A. Мойка автомобиля -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача A. Мойка автомобиля</h3>

  <details>
    <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;cmath&gt;

using namespace std;

int main() {
  int x; // фиксированная оплата
  int y; // стоимость минуты
  int z; // стоимость литра
  int t; // число минут
  int v; // число литров
  cin >> x >> y >> z >> t >> v;

  int cost_min = y * t; // оплата за минуты
  int cost_lit = z * v; // оплата за литры
  int cost = min(x, min(cost_min, cost_lit));

  cout &lt;&lt; cost;
}
</pre>
  </details>
</article>


<!-- Задача B. Настоящие друзья -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача B. Настоящие друзья</h3>

  <details>
    <summary>Решение</summary>
    <p>Задача на бинарный поиск по ответу. Нужно найти такую коробку, чтобы число всех конфет сверху до этой коробки было равно числу конфет в нижних коробках.</p>
    <p>Сумма чисел от 1 до n</p>
		<code>n * (n+1) / 2</code>
		<p>Сумма чисел от A до B</p>
		<code>(B-A+1) * (A+B) / 2</code>

<pre>
#include &lt;iostream&gt;

using namespace std;

typedef long long ll;

ll sum1(ll n) {
  return n * (n + 1) / 2;
}

ll sum2(ll A, ll B) {
  return (B - A + 1) * (A + B) / 2;
}

int main() {
  int t; // число тестов
  cin >> t;

  while (t--) {
    ll k; // число коробок
    cin >> k;

    // сумма чисел от 1 до n
    // n * (n+1) / 2
    // сумма чисел от A до B
    // (B-A+1) * (A+B) / 2

    ll left = 0;
    ll right = k + 1;
    ll mid;

    // бинарный поиск по ответу
    while (right - left > 1) {
      mid = (right + left) / 2;
      if (sum1(mid) &lt;= sum2(mid+1, k)) {
        left = mid;
      } else {
        right = mid;
      }
    }

    if (sum1(left) == sum2(left+1, k)) {
      cout &lt;&lt; "yes" &lt;&lt; '\n';
    } else {
      cout &lt;&lt; "no" &lt;&lt; '\n';
    }
  }
}
</pre>
  </details>
</article>


<!-- Задача C. Пирамида -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>Задача C. Пирамида</h3>

  <details>
    <summary>Решение</summary>
    <p>Создадим вектор кирпичей, для каждого кирпича будем хранить только его меньшую сторону. Отсортируем вектор кирпичей по размеру. Пройдем по всем кирпичам и если очередной кирпич может сделать еще один слой пирамиды, то будем увеличивать высоту пирамиды на один.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  int n; // число кирпичей
  cin >> n;
  int a; // меньшая сторона кирпича
  int b; // большая стороная кирпича
  vector&lt;int&gt; A(n);
  for (int i = 0; i &lt; n; i++) {
    cin >> a >> b; // стороны кирпича
    if (a > b) {
      A[i] = b; // размер кирпича
    } else {
      A[i] = a; // размер кирпича
    }
  }

  sort(A.begin(), A.end());
  int k = 0; // высота пирамиды

  for (int i = 0; i &lt; n; i++) {
    if (A[i] >= 2 * (k + 1) - 1) {
      k++;
    }
  }

  cout &lt;&lt; k;
}
</pre>
  </details>
</article>


<!-- Задача D. Простой феникс -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>Задача D. Простой феникс</h3>

  <details>
    <summary>Решение</summary>
    <p>эффективная атака возможна, если существуют два врага, расположенные рядом по горизонтали или вертикали, и с одной из сторон от этой пары есть свободная клетка для приземления феникса</p>
    <p>Храним позиции врагов в set для быстрой проверки и в vector для итерации</p>
    <p>Для каждого врага проверяем, есть ли соседний враг справа или снизу (чтобы не проверять пары дважды).</p>
    <p>Для каждой найденной пары проверяем, есть ли свободная клетка для приземления феникса с любой стороны от пары.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;set&gt;

using namespace std;

typedef long long ll;

int main() {
  ios_base::sync_with_stdio(false);
  cin.tie(NULL);

  ll n, m; // размер поля
  ll k; // число врагов
  cin >> n >> m >> k;

  set&lt;pair&lt;ll, ll&gt; &gt; enemies;
  vector&lt;pair&lt;ll, ll&gt; &gt; enemy_positions(k);

  for (int i = 0; i &lt; k; i++) {
    cin >> enemy_positions[i].first >> enemy_positions[i].second;
    enemies.insert(enemy_positions[i]);
  }

  // Проверяем каждую пару соседних врагов
  for (const auto& pos : enemy_positions) {
    ll x = pos.first;
    ll y = pos.second;

    // Горизонтальная пара: (x, y) и (x, y+1)
    if (enemies.count({ x, y + 1 })) {
      // Проверяем возможность атаки слева от пары
      if (y - 1 >= 1 && !enemies.count({ x, y - 1 })) {
        cout &lt;&lt; "yes";
        return 0;
      }
      // Проверяем возможность атаки справа от пары
      if (y + 2 &lt;= m && !enemies.count({ x, y + 2 })) {
        cout &lt;&lt; "yes";
        return 0;
      }
    }

    // Вертикальная пара: (x, y) и (x+1, y)
    if (enemies.count({ x + 1, y })) {
      // Проверяем возможность атаки сверху от пары
      if (x - 1 >= 1 && !enemies.count({ x - 1, y })) {
        cout &lt;&lt; "yes";
        return 0;
      }
      // Проверяем возможность атаки снизу от пары
      if (x + 2 &lt;= n && !enemies.count({ x + 2, y })) {
        cout &lt;&lt; "yes";
        return 0;
      }
    }
  }

  cout &lt;&lt; "no";
  return 0;
}
</pre>
  </details>
</article>


<!-- Задача E. Дело о делимости -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>Задача E. Простой феникс</h3>

</article>
