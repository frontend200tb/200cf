<article class="article">
  <strong>Олимпиадное программирование в МИРЭА</strong>
  <p><a href="https://codeforces.com/group/LB1sSRhotq/contests" target="_blank">Codeforces МИРЭА</a></p>
  <p><a href="https://vk.com/mireacoding" target="_blank">vk.com/mireacoding</a></p>
  <p><a href="https://vkvideo.ru/@mireacoding" target="_blank">vkvideo.ru/@mireacoding</a></p>
</article>


<article class="article">
  <h1>4 Основы ДП</h1>
  <p><a href="https://codeforces.com/group/LB1sSRhotq/contest/268096" target="_blank">Codeforces Контест 268096</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#t1">Задача A. Лестница</a>
  <br><a href="#t2">Задача B. Зайчик</a>
  <br><a href="#t3">Задача C. Ход конём</a>
  <br><a href="#t4">Задача D. Стоимость маршрута</a>
  <br><a href="#t5">Задача E. Спуск с горы</a>
  <br><a href="#t6">Задача F. Ядра</a>
  <br><a href="#t7">Задача G. Longpath. Длиннейший путь</a>
  <br><a href="#t8">Задача H. Мирные множества</a>
  <br><a href="#t9">Задача I. Рюкзак</a>
  <br><a href="#t10">Задача J. Плохая подстрока</a>
  <br><a href="#t11">Задача K. Joseph Problem</a>
</article>


<!-- Задача A. Лестница -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>Задача A. Лестница</h3>

  <div class="t1"></div>

  <p>У лестницы n ступенек, пронумерованных числами 1, 2, ..., n снизу вверх. На каждой ступеньке написано число. Начиная с подножия лестницы (его можно считать ступенькой с номером 0), требуется взобраться на самый верх (ступеньку с номером n). За один шаг можно подниматься на одну или на две ступеньки. После подъема числа, записанные на посещенных ступеньках складываются. Нужно подняться по лестнице так, чтобы сумма этих чисел была как можно больше.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла записано целое число n (1 ≤ n ≤ 100). Во второй строке заданы целые числа a1, a2, ..., an через пробел (-10000 ≤ ai ≤ 10000) это числа, записанные на ступеньках.</p>

  <h4>Выходные данные</h4>
  <p>В первой строке выходного файла выведите одно число - максимальную сумму, которую можно получить, поднявшись по данной лестнице.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
2
1 2
</pre>
    <code>3</code>

    <h4>Пример 2</h4>
<pre>
2
2 -1
</pre>
    <code>1</code>

    <h4>Пример 3</h4>
<pre>
3
-1 2 1
</pre>
    <code>3</code>
  </details>

  <details>
    <summary>Решение</summary>

    <h4>Тест 9</h4>
<pre>
6
7388 8451 7463 5742 1534 6567
</pre>
    <code>37145</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  freopen("ladder.in", "rt", stdin);
  freopen("ladder.out", "wt", stdout);

  int n; // число ступенек
  cin >> n;

  vector&lt;int&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  vector&lt;int&gt; DP(n + 1);
  DP[0] = 0;
  DP[1] = A[1];
  for (int i = 2; i &lt;= n; i++) {
    DP[i] = max(DP[i - 2] + A[i], DP[i - 1] + A[i]);
  }

  cout &lt;&lt; DP[n];
}
</pre>
  </details>
</article>


<!-- Задача B. Зайчик -->
<article class="article">
  <div class="anchor" id="t2"></div>
  <h3>Задача B. Зайчик</h3>

  <div class="t2"></div>

  <p>Зайчик прыгает по прямой просеке, для удобства разделенной на n клеток. Клетки пронумерованы по проядку натуральными числами от 1 до n. Некоторые клетки заблочены: если зайчик прыгнет на такую клетку, ему несдобровать. Некоторые другие клетки просеки поросли вкусной зеленой травой: прыгнув на такую клетку, зайчик сможет отдохнуть и подкрепиться.</p>
  <p>Зайчик начинает свой путь из клетки с номером 1 и хочет попасть в клетку с номером n, по пути ни разу не провалившись в болото и вкушав как можно больше вкусной зеленой травы. Конструктивные особенности зайчика таковы, что из клетки с номером k он может прыгнуть лишь в клетки с номерами k+1, k+3 и k+5.</p>
  <p>Выясните, какое максимальное количество клеток с травой сможет посетить зайчик на своем пути.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла задано число n - количество клеток (2 ≤ n ≤ 1000). Вторая строка состоит из n символов; i-ый символ соответствует i-ой клетке просеки. Символ 'w' обозначает болото, символ '"' - зеленую траву, а символ '.' соответствует клетке без особенностей. Гарантируется, что первая и последняя клетки не содержат болот и травы.</p>

  <h4>Выходные данные</h4>
  <p>В первой строкке выходного файла выведите одно число - максимальное количества клеток с травой, которые зайчик сможет посетить на своем пути. Если зайчику не удастся оказаться в клетке с номером n, выведите -1.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
<pre>
4
."".
</pre>
    <code>2</code>

    <h4>Пример 2</h4>
<pre>
5
.w"..
</pre>
    <code>0</code>

    <h4>Пример 3</h4>
<pre>
9
.www.www.
</pre>
    <code>-1</code>
  </details>

  <details>
    <summary>Решение</summary>

    <h4>Тест 6</h4>
<pre>
3
.w.
</pre>
    <code>-1</code>

    <h4>Тест 9</h4>
<pre>
4
..w.
</pre>
    <code>0</code>

    <h4>Тест 16</h4>
<pre>
12
...w"w.w""..
</pre>
    <code>2</code>

    <h4>Тест 17</h4>
<pre>
22
."......"..w.w........
</pre>
    <code>2</code>

    <h4>Тест 18</h4>
<pre>
32
."ww"..."w.........."......w....
</pre>
    <code>4</code>

    <h4>Тест 19</h4>
<pre>
42
."ww""."".."""."ww.""".w..w.w"."""."".""w.
</pre>
    <code>19</code>

    <h4>Тест 22</h4>
<pre>
72
.w"""""w".w""w.""w"""w"".w""w"w"w"""""ww.w".w""""".www""".""ww"w""""."".
</pre>
    <code>34</code>

    <h4>Тест 24</h4>
<pre>
136
."..ww.""""..""".w"..""."""""""..w"""w.w".""".""ww"w.w."""""""""."".."..w.."""w..w"""w""w..".""w."w.."""."""."w."w"""w"w."""""ww""w"""w.
</pre>
    <code>68</code>

    <h4>Тест 26</h4>
<pre>
493
.""w"w"""www..."www"www"."w""""""""""""""ww"ww"""w"w""".""""ww""w"""w".""""ww""""w""."w.""""""w""""w""""w"w"""w".ww""w""w""""..""".".".w"w"""""".""".""""ww"".""w""w".""""""""w""w""""w".w".""""""""."."""w""."w"""."""w"wwww""..""w"ww.w""."..""""".""""""""ww.""""w"ww.w"ww.."w""w""".""w"w"""."ww"""""www""""w"""""""""w"w""""."""".ww"w"w""w."..""ww"".""""w"w"w"w"""w""ww""."w"".w"w""""w""ww".w"""""w"""w"""""w".ww""w.ww"""w"""""ww"w"""""""""w""ww"ww.""""w..""ww"""""w""ww"w"".w"""w"."w"""""w""""w.
</pre>
    <code>254</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  freopen("lepus.in", "rt", stdin);
  freopen("lepus.out", "wt", stdout);

  int n; // число клеток
  cin >> n;

  vector&lt;char&gt; A(n + 1);
  for (int i = 1; i &lt;= n; i++) {
    cin >> A[i];
  }

  vector&lt;int&gt; DP(n + 1);
  DP[1] = 0;

  for (int i = 2; i &lt;= n; i++) {
    // если на клетке болото
    if (A[i] == 'w') {
      DP[i] = -1;

    // если на клетку нельзя попасть из болота
    } else if (i > 5 && A[i - 5] == 'w' && A[i - 3] == 'w' && A[i - 1] == 'w') {
      DP[i] = -1;
    } else if (i > 3 && i &lt;= 5 && A[i - 3] == 'w' && A[i - 1] == 'w') {
      DP[i] = -1;
    } else if (i == 3 && A[i - 1] == 'w') {
      DP[i] = -1;

    // если на клетку нельзя попасть из неоступной клетки
    } else if (i > 5 && DP[i - 5] == -1 && DP[i - 3] == -1 && DP[i - 1] == -1) {
      DP[i] = -1;
    } else if (i > 3 && i &lt;= 5 && DP[i - 3] == -1 && DP[i - 1] == -1) {
      DP[i] = -1;
    } else if (i == 3 && DP[i - 1] == -1) {
      DP[i] = -1;

    // если на клетку можно попасть и на ней трава
    } else if (A[i] == '"') {
      if (A[i - 1] != 'w' && DP[i-1] != -1) DP[i] = DP[i - 1] + 1;
      if (i > 3 && A[i - 3] != 'w' && DP[i-3] != -1) DP[i] = max(DP[i], DP[i - 3] + 1);
      if (i > 5 && A[i - 5] != 'w' && DP[i-5] != -1) DP[i] = max(DP[i], DP[i - 5] + 1);

    // если на клетку можно попасть и на ней пусто
    } else if (A[i] == '.') {
      if (A[i - 1] != 'w' && DP[i - 1] != -1) DP[i] = DP[i - 1];
      if (i > 3 && A[i - 3] != 'w' && DP[i - 3] != -1) DP[i] = max(DP[i], DP[i - 3]);
      if (i > 5 && A[i - 5] != 'w' && DP[i - 5] != -1) DP[i] = max(DP[i], DP[i - 5]);
    }
  }

  cout &lt;&lt; DP[n];
}
</pre>
  </details>
</article>


<!-- Задача C. Ход конём -->
<article class="article">
  <div class="anchor" id="t3"></div>
  <h3>Задача C. Ход конём</h3>

  <div class="t3"></div>

  <p>Дана прямоугольная доска N x M (N строк и M столбцов). В левом верхнем углу находится шахматный конь, которого необходимо переместить в правый нижний угол доски.</p>
  <p>При этом конь может ходить следующим образом:</p>
  <ol>
    <li>На две клетки вниз и одну вправо</li>
    <li>На одну клетку вниз и на две вправо</li>
  </ol>
  <p>Необходимо определить, сколько существует различных маршрутов, ведущих из левого верхнего в правый нижний угол.</p>

  <h4>Входные данные</h4>
  <p>В первой строке входного файла находятся два натуральных числа N и M (1 ≤ N, M ≤ 50).</p>

  <h4>Выходные данные</h4>
  <p>В выходной файл выведите единственное число - количество способов добраться конем до правого нижнего угла доски.</p>

  <details>
    <summary>Примеры</summary>
    <h4>Пример 1</h4>
    <code>3 2</code>
    <code>1</code>

    <h4>Пример 3</h4>
    <code>31 34</code>
    <code>293930</code>
  </details>

  <details>
    <summary>Решение</summary>
    <p>Соберем вектор DP на 2 клетки больше вправо и на 2 клетки больше вниз, поскольку конь может ходить на 2 вправо и на 2 вниз.В каждой клетке будем считать число способов в нее попасть.</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

int main() {
  freopen("knight.in", "rt", stdin);
  freopen("knight.out", "wt", stdout);

  int n, m; // размер доски
  cin >> n >> m;

  vector&lt;vector&lt;int&gt; &gt; DP(n+2, vector&lt;int&gt;(m+2));
  DP[0][0] = 1;

  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; m; j++) {
      DP[i + 1][j + 2] += DP[i][j];
      DP[i + 2][j + 1] += DP[i][j];
    }
  }

  cout &lt;&lt; DP[n - 1][m - 1];
}
</pre>
  </details>
</article>


<!-- Задача D. Стоимость маршрута -->
<article class="article">
  <div class="anchor" id="t4"></div>
  <h3>Задача D. Стоимость маршрута</h3>

  <div class="t4"></div>

  <p>На каждой клетке шахматной доски размеров 8х8 записано целое неотрицательное число. Король может перемещаться по шахматной доске из левого нижнего угла в правый верзний, перемещаясь только вправо, вверх или по диагонали вправо вверх. При этом стоимость прохода через данную клетку равна числу, записанному на этой клетке.</p>
  <p>Переместите короля из левого нижнего угла в правый верхний с наименьшей стоимостью прохода.</p>

  <h4>Входные данные</h4>
  <p>На вход программе подается восемь строк, каждая строка содержит восемь целых неотрицательных чисел, не превосходящих 1000. В левом нижнем углу всегда записано число 0.</p>

  <h4>Выходные данные</h4>
  <p>Выведите единственное число - минимальную стоимость прохода из левого нижнего угла в правый верхний.</p>

  <details>
    <summary>Пример</summary>
<pre>
9 9 9 9 9 9 1 9
9 9 9 9 9 1 9 2
9 9 9 9 9 9 1 9
9 9 9 9 9 9 9 9
9 9 9 9 9 9 9 9
9 9 9 9 9 9 9 9
9 9 9 9 9 9 9 9
0 9 9 9 9 9 9 9
</pre>
    <code>56</code>
  </details>

  <details>
    <summary>Решение</summary>
    <h4>Тест 2</h4>
<pre>
1 2 0 2 0 1 0 1
2 2 2 0 1 1 2 0
2 1 2 2 0 1 0 2
0 2 2 1 2 1 0 0
1 1 1 2 0 1 0 2
0 2 0 1 1 0 2 1
2 1 2 0 0 0 2 1
0 0 2 2 1 2 0 0
</pre>
    <code>3</code>

<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
  freopen("king2.in", "rt", stdin);
  freopen("king2.out", "wt", stdout);

  vector&lt;vector&lt;int&gt; &gt; A(8, vector&lt;int&gt; (8));
  for (int i = 0; i &lt; 8; i++) {
    for (int j = 0; j &lt; 8; j++) {
      cin >> A[i][j];
    }
  }

  vector&lt;vector&lt;int&gt; &gt; DP(8, vector&lt;int&gt; (8, 0));

  // базовый случай
  DP[7][0] = A[7][0];
  // левый столбец
  for (int i = 6; i >= 0; i--) {
    DP[i][0] = DP[i+1][0] + A[i][0];
  }
  // нижняя строка
  for (int i = 1; i &lt; 8; i++) {
    DP[7][i] = DP[7][i-1] + A[7][i];
  }

  for (int i = 6; i >= 0; i--) {
    for (int j = 1; j &lt; 8; j++) {
      DP[i][j] = min(DP[i+1][j], DP[i][j-1]);
      DP[i][j] = min(DP[i][j], DP[i + 1][j - 1]) + A[i][j];
    }
  }

  cout &lt;&lt; DP[0][7];
}
</pre>
  </details>
</article>


<!-- Задача E. Спуск с горы -->
<article class="article">
  <div class="anchor" id="t5"></div>
  <h3>Задача E. Спуск с горы</h3>

  <div class="t5"></div>

</article>


<!-- Задача F. Ядра -->
<article class="article">
  <div class="anchor" id="t6"></div>
  <h3>Задача F. Ядра</h3>

  <div class="t6"></div>

</article>


<!-- Задача G. Longpath. Длиннейший путь -->
<article class="article">
  <div class="anchor" id="t7"></div>
  <h3>Задача G. Longpath. Длиннейший путь</h3>

  <div class="t7"></div>

</article>


<!-- Задача H. Мирные множества -->
<article class="article">
  <div class="anchor" id="t8"></div>
  <h3>Задача H. Мирные множества</h3>

  <div class="t8"></div>

</article>


<!-- Задача I. Рюкзак -->
<article class="article">
  <div class="anchor" id="t9"></div>
  <h3>Задача I. Рюкзак</h3>

  <div class="t9"></div>

</article>


<!-- Задача J. Плохая подстрока -->
<article class="article">
  <div class="anchor" id="t10"></div>
  <h3>Задача J. Плохая подстрока</h3>

  <div class="t10"></div>

</article>


<!-- Задача K. Joseph Problem -->
<article class="article">
  <div class="anchor" id="t11"></div>
  <h3>Задача K. Joseph Problem</h3>

  <div class="t11"></div>

</article>
