<!-- Задача G. Очередь -->
<div class="time-memory">(Время 2с. Память 256мб)</div>

<p>В зимний холодный вечер наш герой Вася стоял в очереди на вокзале за билетом на финал чемпионата Codeforces. Как обычно это бывает, кассир, сказав, что он отлучится на 5 минут, ушел на целый час... Тогда Вася, чтобы не скучать в это время, стал изучать такой механизм, как очередь. Наблюдения потрясли Васю.</p>

<p>Каждый человек характеризуется числами ai — важностью его дел (чем это число больше, тем важнее его дело), и числом ci — характеристика его совести. Числа ai образуют перестановку чисел от 1 до n.</p>

<p>Пусть на данный момент очередь состоит из n - 1 людей. Рассмотрим, как ведет себя пришедший номер n. Первым делом он встает в конец текущей очереди, а дальше поступает следующим образом: если у человека, который стоит перед ним важность дел ai меньше чем an, то они меняются местами (выглядит это так: человек номер n спрашивает у предыдущего: «Эээ... простите, пожалуйста, у меня очень важное дело... можете меня пропустить вперед?»), затем он опять спрашивает у впереди стоящего человека, и так далее. Если же ai больше чем an, то продвижение вперед заканчивается. Но такую операцию обмена человек номер n может совершить не более, чем cn раз.</p>

<p>В нашей задаче будем считать, что к моменту, когда человек номер n придет в очередь, процесс обменов в очереди из n - 1 людей уже закончится. Если обмен возможен, то он обязательно происходит.</p>

<p>Ваша задача — помочь Васе промоделировать описанный процесс и найти, в каком порядке пришедшие люди будут располагаться в очереди после окончания всех обменов.</p>

<h4>Входные данные</h4>
<p>В первой строке входных данных находится целое число n — количество людей, пришедших в данную очередь (1 ≤ n ≤ 10⁵). Далее в n строках заданы описания людей в порядке их прихода — целые числа ai и ci (1 ≤ ai ≤ n, 0 ≤ ci ≤ n), записанные через пробел. Каждое описание находится на отдельной строке. Все ai различны.</p>

<h4>Выходные данные</h4>
<p>Выведите перестановку чисел от 1 до n, означающую образованную по описанным правилам очередь в порядке от начала к концу. В этой последовательности i-ое число означает номер человека, который будет стоять в очереди на месте номер i после завершения процесса обменов. Люди нумеруются с 1 в порядке, в котором они заданы во входных данных. Числа разделяйте пробелом.</p>

<details>
  <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
2
1 0
2 1
</pre>
  <code>2 1</code>

  <h4>Пример 2</h4>
<pre>
3
1 3
2 3
3 3
</pre>
  <code>3 2 1</code>

  <h4>Пример 3</h4>
<pre>
5
2 3
1 4
4 3
3 1
5 2
</pre>
  <code>3 1 5 4 2</code>
</details>

<details>
  <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;forward_list&gt;

using namespace std;

template&lt;class T&gt; inline void smin(T& a, T b) { if (b < a)a = b; }
template&lt;class T&gt; inline void smax(T& a, T b) { if (a < b)a = b; }

const int maxn = 100000 + 100;
const int CTV = 800;

int n;
int a[maxn], c[maxn];
struct Block {
  forward_list&lt;int&gt; L;
  int len;
  int maxa;
  Block() { L.clear(); len = 0; maxa = -1; };
};
forward_list&lt;Block&gt; Q;

int ans[maxn];

int main() {
  ios_base::sync_with_stdio(false);

  cin >> n;
  for (int i = 0; i &lt; n; i++) {
    cin >> a[i] >> c[i], smin(c[i], i);
  }

  Q.push_front(Block());
  for (int i = 0; i &lt; n; i++) {
    auto it = Q.begin();
    while (it->len &lt; c[i] && it->maxa &lt; a[i]) c[i] -= it->len, it++;
    auto& cur = *it;
    auto it2 = cur.L.before_begin();
    while (c[i]) {
      if (a[*next(it2)] &lt; a[i]) it2++, c[i]--;
      else break;
    }
    cur.L.insert_after(it2, i);
    cur.len++;
    smax(cur.maxa, a[i]);
    if (cur.len > CTV) {
      auto nwit = Q.insert_after(it, Block());
      nwit->L.splice_after(nwit->L.before_begin(), it->L,
      next(it->L.begin(), CTV / 2), it->L.end());
      int mx;
      int nwlen = 0;
      mx = 0; for (int x : nwit->L) smax(mx, a[x]), nwlen++;
      nwit->maxa = mx;
      nwit->len = nwlen;
      mx = 0; for (int x : it->L) smax(mx, a[x]);
      it->maxa = mx;
      it->len -= nwlen;
    }
  }

  int pos = n;
  for (auto cur : Q) for (int x : cur.L) {
    ans[--pos] = x;
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; 1 + ans[i] &lt;&lt; ' ';
  }
}
</pre>
</details>