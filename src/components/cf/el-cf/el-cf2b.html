<!-- Задача B. Наименее круглый путь -->
<div class="time-memory">(Время 2с. Память 64мб)</div>

<p>Задана квадратная матрица n x n, состоящая из неотрицательных целых чисел. Вам надо найти такой путь на ней, который</p>
<ol>
  <li>начинается в левой верхней ячейке матрицы;</li>
  <li>каждой следующей ячейкой имеет правую или нижнюю от текущей;</li>
  <li>заканчивается в правой нижней клетке.</li>
</ol>

<p>Кроме того, если перемножить все числа вдоль пути и посмотреть на получившиеся произведение, то это число должно быть как можно менее «круглым». Иными словами оно должно заканчиваться на наименьшее возможное количество нулей.</p>

<h4>Входные данные</h4>
<p>В первой строке содержится целое число n (2 ≤ n ≤ 1000), n — размер заданной матрицы. Далее в n строках содержатся элементы матрицы (целые неотрицательные числа, не превосходящие 10⁹).</p>

<h4>Выходные данные</h4>
<p>В первую строку выведите искомое наименьшее количество концевых нулей в произведении чисел вдоль пути. Во вторую выведите сам путь.</p>

<details>
  <summary>Пример</summary>
<pre>
3
1 2 3
4 5 6
7 8 9
</pre>
<pre>
0
DDRR
</pre>
</details>

<details>
  <summary>Решение</summary>

  <div>
    <a href="https://codeforces.com/contest/2/problem/B" target="_blank">Задача 2B</a>
    <br><a href="https://codeforces.com/contest/2" target="_blank">Codeforces Beta Round 2 2010-02-25</a>
  </div>

    <p>Количество нулей в конце числа определяется количеством пар множителей 2 x 5 в его разложении. Таким образом, задача сводится к поиску пути с минимальным количеством либо двоек, либо пятерок в произведении.</p>
    <p>Для каждой ячейки матрицы вычисляется:</p>
    <ul>
      <li>matrix[i][j].first - количество двоек в разложении числа</li>
      <li>matrix[i][j].second - количество пятерок в разложении числа</li>
    </ul>
    <p>Функция power() вычисляет, сколько раз число делится на заданную базу (2 или 5).</p>
    <p>Если в матрице встречается 0, то: Произведение вдоль любого пути, проходящего через 0, будет равно 0, Число 0 имеет 1 конечный ноль, Если оптимальный путь без нуля дает больше 1 нуля, то путь через 0 будет лучше, Для нуля устанавливается k = 10 (1 двойка и 1 пятерка)</p>
    <p>Создаются две матрицы DP:</p>
    <ul>
      <li>m2[i][j] - минимальное количество двоек на пути до ячейки (i,j)</li>
      <li>m5[i][j] - минимальное количество пятерок на пути до ячейки (i,j)</li>
    </ul>
    <code>m2[i][j] = min(m2[i-1][j], m2[i][j-1]) + matrix[i][j].first</code>
    <code>m5[i][j] = min(m5[i-1][j], m5[i][j-1]) + matrix[i][j].second</code>
    <p>Функция find_path() восстанавливает путь</p>
    <ul>
      <li>Начинает с конечной ячейки (n-1, n-1)</li>
      <li>Проверяет, откуда пришли: сверху (D) или слева (R)</li>
      <li>Собирает путь в обратном порядке</li>
    </ul>
    <p>Из двух путей (с минимальными двойками и минимальными пятерками) выбирается тот, который дает меньшее количество нулей</p>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;

using namespace std;

#define MAX 100000

vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; matrix;

int power(long long number, long long base) {
  int p = 0;
  while (number % base == 0LL)
    number /= base,
    p++;
  return p;
}

int get_matrix(bool which, int r, int c) {
  if (which)
    return matrix[r][c].second;
  return matrix[r][c].first;
}

// 2 = false, 5 = true
string find_path(int r, int c, bool which, vector&lt;vector&lt;int&gt; &gt;& mx) {
  string path = "";
  while (r || c) {
    if (r > 0 && mx[r][c] - get_matrix(which, r, c) == mx[r - 1][c]) {
      r--;
      path = "D" + path;
    } else if (c > 0 && mx[r][c] - get_matrix(which, r, c) == mx[r][c - 1]) {
      c--;
      path = "R" + path;
    }
  }
  return path;
}

int main() {
  int n; // размер матрицы
  cin >> n;

  long long k; // число внутри матрицы
  bool zero = false;
  int zj;

  matrix = vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt;(n, vector&lt;pair&lt;int, int&gt; &gt;(n));
  vector&lt;vector&lt;int&gt; &gt; m2(n, vector&lt;int&gt;(n, MAX));
  vector&lt;vector&lt;int&gt; &gt; m5(n, vector&lt;int&gt;(n, MAX));

  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      cin >> k;
      if (k == 0LL) {
        zero = true;
        zj = j;
        k = 10LL;
      }
      matrix[i][j] = make_pair(power(k, 2LL), power(k, 5LL));
    }
  }

  m2[0][0] = matrix[0][0].first, m5[0][0] = matrix[0][0].second;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (j > 0) {
        m2[i][j] = min(m2[i][j], matrix[i][j].first + m2[i][j - 1]);
        m5[i][j] = min(m5[i][j], matrix[i][j].second + m5[i][j - 1]);
      }
      if (i > 0) {
        m2[i][j] = min(m2[i][j], matrix[i][j].first + m2[i - 1][j]);
        m5[i][j] = min(m5[i][j], matrix[i][j].second + m5[i - 1][j]);
      }
    }
  }

  int mini = min(m2[n - 1][n - 1], m5[n - 1][n - 1]);

  string path;

  if (zero && mini > 1) {
    mini = 1;
    for (int j = 0; j &lt; zj; j++) {
      path = path + "R";
    }
    for (int i = 0; i &lt; n - 1; i++) {
      path = path + "D";
    }
    for (int j = zj; j &lt; n - 1; j++) {
      path = path + "R";
    }
  } else {
    if (m5[n - 1][n - 1] == mini) path = find_path(n - 1, n - 1, true, m5);
    else if (m2[n - 1][n - 1] == mini) path = find_path(n - 1, n - 1, false, m2);
  }

  if (mini &lt; 0) {
    cout &lt;&lt; 1 &lt;&lt; '\n';
  } else {
    cout &lt;&lt; mini &lt;&lt; '\n';
  }
  cout &lt;&lt; path;
}
</pre>
</details>
