<!-- Задача F. Умный мальчик -->
<div class="time-memory">(Время 4с. Память 256мб)</div>

<p>Однажды Вася и Петя придумали новую игру и назвали ее «Умный мальчик». Для игры они зафиксировали некоторый набор слов — словарь. Допускается, что словарь содержит одинаковые слова.</p>

<p>Правила игры таковы: сначала первый игрок выбирает любую букву (слово длины 1) из любого слова из словаря и записывает ее на лист бумаги. Второй игрок приписывает к этой букве некоторую другую в начало или в конец, таким образом получая уже слово длины 2, затем опять ходит первый игрок, и он опять приписывает некоторую букву в начало или в конец, получая слово длины 3. И так далее. Но игрок не имеет права нарушать условие: новое записанное слово должно являться подстрокой некоторого слова из словаря. Проигрывает тот, кто не может увеличить текущую строку так, чтобы не нарушалось условие.</p>

<p>Также если после хода на бумаге записана некоторая строка s, то игрок, сделавший этот ход, получает количество очков по формуле:</p>

<code>score(s) = value(si) * max {value(si)} + num(s)</code>

<p>где:</p>
<ul>
  <li>value(c) — порядковый номер символа c в латинском алфавите, пронумерованном с 1. Например, value(a) = 1, а value(z) = 26.</li>
  <li>num(s) — количество слов из словаря, где встречается строка s как подстрока хотя бы один раз.</li>
</ul>

<p>Ваша задача — узнать, кто выиграет в этой игре, и итоговый счет. Каждый игрок играет оптимально, и в первую очередь стремится выиграть, во вторую — максимизировать свои очки, в третью — минимизировать очки соперника.</p>

<h4>Входные данные</h4>
<p>В первой строке входных данных записано целое число n — количество слов в зафиксированном словаре (1 ≤ n ≤ 30). Далее в n строках по одному на строке записаны слова из словаря — непустые строки, состоящие из строчных букв латинского алфавита, длиной не более 30 символов. Среди списка слов могут быть одинаковые.</p>

<h4>Выходные данные</h4>
<p>В первую строку выходных данных выведите строку «First» или «Second» — кто выиграет в игре. Во вторую строку выведите количество очков у первого игрока и количество очков у второго игрока после завершения игры. Числа разделите одним пробелом.</p>

<details>
  <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
2
aba
abac
</pre>
<pre>
Second
29 35
</pre>

  <h4>Пример 2</h4>
<pre>
3
artem
nik
max
</pre>
<pre>
First
2403 1882
</pre>
</details>

<details>
  <summary>Решение</summary>
<pre>
#include &lt;iostream>
#include &lt;vector>
#include &lt;map>
#include &lt;algorithm>
#include &lt;string>

using namespace std;

typedef pair&lt;int, int> ii;
typedef pair&lt;int, ii> iii;

int n; // число слов
string s[30]; // список слов

map&lt;string, iii> m;

int num(string str) {
  int ans = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; (int)s[i].size() - (int)str.size() + 1; j++) {
      int g = 1;
      for (int k = 0; k &lt; (int)str.size(); k++) {
        if (str[k] != s[i][j + k]) {
          g = 0;
          break;
        }
      }
      if (g) {
        ans++;
        break;
      }
    }
  }
  return ans;
}

iii make(int a, int b, int c) {
  return make_pair(a, make_pair(b, c));
}

iii getans(string s) {
  if (m.count(s))
    return m[s];
  iii ans = make(0, 0, 0);
  for (int i = 0; i &lt; 52; i++) {
    string tmp;
    if (i >= 26) {
      tmp = s;
      tmp += "o";
      tmp[(int)tmp.size() - 1] = (char)(i + 'a' - 26);
    } else {
      tmp = "o" + s;
      tmp[0] = (char)(i + 'a');
    }

    int z = num(tmp);
    if (z) {
      iii o = getans(tmp);
      int bonus = 0;
      int bm = 0;
      for (int j = 0; j &lt; (int)tmp.size(); j++) {
        bm = max(bm, (int)(tmp[j] - 'a' + 1));
        bonus += tmp[j] - 'a' + 1;
      }
      bonus *= bm;
      bonus += z;
      ans = max(ans, make(1 ^ o.first, -o.second.second + bonus, -o.second.first));
    }
  }

  m[s] = ans;
  return ans;
}

int main() {
  cin >> n;
  for (int i = 0; i &lt; n; i++) {
    cin >> s[i];
  }

  sort(s, s + n);
  iii tmp = getans("");

  if (tmp.first == 1) {
    cout &lt;&lt; "First" &lt;&lt; endl;
  } else {
    cout &lt;&lt; "Second" &lt;&lt; endl;
  }
  cout &lt;&lt; tmp.second.first &lt;&lt; ' ' &lt;&lt; -tmp.second.second;
}
</pre>
</details>
