<!-- Задача H. Великий марафон -->
<div class="time-memory">(Время 4с. Память 256мб)</div>

<p>В день празднования Дня Зависимости в Берляндии, было решено устроить грандиозный марафон. Берляндия состоит из n городов, некоторые из которых связаны двусторонними дорогами. Каждая дорога имеет некоторую длину. Города пронумерованы от 1 до n. Известно, что из любого города можно добраться по дорогам в любой другой.</p>

<p>В соревновании принимают участие n бегунов, по одному из каждого города. Но берляндские бегуны по своей натуре — болтуны, и поэтому жюри приняло меры для предотвращения больших скоплений участников марафона. Жюри решило, чтобы каждый спортсмен стартовал из своего родного города. Перед стартом каждый спортсмен получит листок бумаги, на котором будет написано, в каком городе у него расположен финиш. Финиш для каждого спортсмена назначается случайным образом, но не может совпадать с его стартом. Допускается, чтобы у нескольких спортсменов финиш располагался в одном и том же городе. Все спортсмены стартуют одновременно, и каждый бежит от старта до финиша по кратчайшему маршруту. Скорости всех спортсменов одинаковые и равны 1.</p>

<p>По итогам соревнования будет составлена таблица результатов, в которой спортсмены будут отсортированы по неубыванию времени, которое они потратили на преодоление дистанции. Первые g спортсменов в этой таблице получат золотые медали, следующие s спортсменов — серебряные, а остальные бронзовые. Причем, если два или более спортсмена потратили одинаковое время на преодоление дистанции, то они упорядочиваются по возрастанию номеров городов, из которых они стартовали. Из этого следует, что никакие два спортсмена не делят одно и то же место.</p>

<p>По правилам соревнования количество золотых медалей g должно удовлетворять неравенству g1 ≤ g ≤ g2, где g1 и g2 исторически сложившиеся значения. Аналогично, количество серебряных медалей s должно удовлетворять неравенству s1 ≤ s ≤ s2, где s1 и s2 тоже исторически сложившиеся значения.</p>

<p>В настоящий момент, до начала соревнования, неизвестны пункты назначения каждого из спортсменов. Однако пресса требует каких-либо подробностей, и поэтому Вам поручили подсчитать количество способов распределить медали. Два способа распределения считаются различными, если хотя бы один спортсмен получил при этих распределениях медали разного достоинства.</p>

<h4>Входные данные</h4>
<p>В первой строке входных данных заданы целые числа n и m (3 ≤ n ≤ 50, n - 1 ≤ m ≤ 1000), где n — количество городов в Берляндии, а m — количество дорог.</p>

<p>Далее в m строках даны описания дорог в виде тройки целых чисел v, u, c — номера соединяемых городов и ее длина (1 ≤ v, u ≤ n, v ≠ u, 1 ≤ c ≤ 1000). Между каждой парой городов — не более одной дороги.</p>

<p>В последней строке записаны целые числа g1, g2, s1, s2 (1 ≤ g1 ≤ g2, 1 ≤ s1 ≤ s2, g2 + s2 &lt; n). Числа во входных данных, расположенные на одной строке, разделены пробелом.</p>

<h4>Выходные данные</h4>
<p>Выведите единственное число — количество способов распределить медали. Гарантируется, что это число помещается в стандартный знаковый 64-битный тип данных.</p>

<details>
  <summary>Примеры</summary>
  <h4>Пример 1</h4>
<pre>
3 2
1 2 1
2 3 1
1 1 1 1
</pre>
  <code>3</code>

  <h4>Пример 2</h4>
<pre>
4 5
1 2 2
2 3 1
3 4 2
4 1 2
1 3 3
1 2 1 1
</pre>
  <code>19</code>

  <h4>Пример 3</h4>
<pre>
3 3
1 2 2
2 3 1
3 1 2
1 1 1 1
</pre>
  <code>4</code>
</details>

<details>
  <summary>Решение</summary>
<pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

typedef long long ll;
typedef pair&lt;int, int&gt; ii;
typedef vector&lt;ii&gt; vii;

int n;
int m;

int g1, g2, s1, s2;
int dist[50][50];

ii l[50], r[50];
ll table[51][51][51];

vii v[50];
ii zlo[50][50];

int check2(int x) {
  return x >= s1 && x &lt;= s2;
}

ll getans(int p1, int p2) {
  for (int i = n-1; i >= 0; i--) {
    for (int c1 = 0; c1 &lt; min(g2 + 1, i + 1); c1++) {
      for (int c2 = 0; c2 &lt; i + 1; c2++) {
        ll& ans = table[c1][c2][i];
        if (i == p1) {
          ans = table[c1 + 1][c2][i + 1];
          continue;
        }
        if (i == p2) {
          ans = table[c1][c2 + 1][i + 1];
          continue;
        }

        ans = 0;
        if (l[i] &lt; l[p1]) {
          ans += table[c1 + 1][c2][i + 1];
        }
        if (r[i] > r[p2]) {
          ans += table[c1][c2 + 1][i + 1];
        }
        if (zlo[i][p1] &lt; r[p2]) {
          ans += table[c1][c2][i + 1];
        }

      }
    }
  }

  return table[0][0][0];
}

int main() {
  cin >> n >> m;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      dist[i][j] = (int)(1e9);
    }
  }
  for (int i = 0; i &lt; n; i++) {
    dist[i][i] = 0;
  }

  for (int i = 0; i &lt; m; i++) {
    int a, b, c;
    cin >> a >> b >> c;
    a--;
    b--;
    dist[a][b] = min(dist[a][b], c);
    dist[b][a] = min(dist[b][a], c);
  }

  cin >> g1 >> g2 >> s1 >> s2;

  for (int k = 0; k &lt; n; k++) {
    for (int i = 0; i &lt; n; i++) {
      for (int j = 0; j &lt; n; j++) {
        dist[i][j] = min(dist[i][k] + dist[k][j], dist[i][j]);
      }
    }
  }

  for (int i = 0; i &lt; n; i++) {
    r[i] = make_pair(-1, 0);
    l[i] = make_pair(1000000000, 0);
    for (int j = 0; j &lt; n; j++) {
      if (i != j) {
        v[i].push_back(make_pair(dist[i][j], i));
        l[i] = min(l[i], make_pair(dist[i][j], i));
        r[i] = max(r[i], make_pair(dist[i][j], i));
      }
    }
  }

  for (int i = 0; i &lt; n; i++) {
    sort(v[i].begin(), v[i].end());
  }

  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (r[i] > l[j]) {
        zlo[i][j] = *lower_bound(v[i].begin(), v[i].end(), l[j]);
      } else {
        zlo[i][j] = make_pair(1000000000, 0);
      }
    }
  }

  if (0) {
    for (int i = 0; i &lt; n; i++) {
      cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; l[i].first &lt;&lt; ' ' &lt;&lt; l[i].second
      &lt;&lt; ' ' &lt;&lt; r[i].first &lt;&lt; ' ' &lt;&lt; r[i].second &lt;&lt; endl;
    }
  }

  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (i &lt;= g2 && i >= g1 && check2(n - i - j)) {
        table[i][j][n] = 1;
      } else {
        table[i][j][n] = 0;
      }
    }
  }

  ll ans = 0;
  for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
      if (i != j && l[i] &lt; r[j]) {
        ans += getans(i, j);
      }
    }
  }

  cout &lt;&lt; ans;
}
</pre>
</details>