<article class="article">
  <strong>EDU ITMO пилотный курс. Михаил Мирзаянов</strong>
  <p><a href="https://codeforces.com/group/kjV5ruxRwB/contests" target="_blank">Codeforces Тренировки выходного дня</a></p>
</article>


<article class="article">
  <h1>1 Z-функция строки</h1>
  <p><a href="https://codeforces.com/group/kjV5ruxRwB/contest/634575" target="_blank">Codeforces Контест 634575</a></p>
  <p>(личная, ioi)</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#t1">1 Z-функция строки</a>
</article>


<!-- 1 Z-функция строки -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>1 Z-функция строки</h3>

  <p>Это занятие посвящено одной из базовых тем stringology - z-функции строки. Эта тема не требует предварительных навыков, кроме базовой техники программирования.</p>

  <h4>Определения</h4>
  <p><strong>Строка</strong> - это конечная (возможно, пустая) последовательность символов. Длина строки s обозначается как |s| мощность множества. Символы строки нумеруются от 0 до s-1.</p>
  <p><strong>Алфавит строки</strong> - это все возможные символы строки.</p>
  <p><strong>Подстрока</strong> - последовательность подряд идущих символов строки. Подстрока задается ее позицией внутри строки от i до j. Длина подстроки равна j-i+1.</p>
  <p>string строка. row строка в матрице. line строка в текстовом файле.</p>
  <p>Вхождением строки p в строку t называют такую пару индексов (i,j), что p=t[i...j].</p>
  <p>Префикс - это подстрока, которая начинается с начала строки. Всего у строки s+1 префиксов, пустой и полный тоже учитываются.</p>
  <p>Суффикс - это подстрока, которая заканчивается концом строки. Всего у строки s+1 суффиксов, пустой и полный тоже учитываются.</p>
  <p>Собственный префикс и собственный суффикс это не пустой и не совпадающий со строкой префикс и суффикс.</p>

  <h4>Поиск подстроки в строке</h4>
  <p>Основная задача stringology: string searching problem или string matching problem.</p>
  <p>Задана строка t (text) и строка p (pattern). Найдите все вхождения строки p в строку t.</p>
  <p>Если n=|t| и m=|p|, то наивный алгоритм полного перебора работает за время O(nm).</p>
<pre>
for (int i = 0; i &lt; n - m; i++) {
  mismatch = false;
  for (int k = 0; k &lt; m - 1; k++) {
    if (p[k] != t[i+k]) {
      mismatch = true;
      break;
    }
  }
  if (!mismatch) {
    cout &lt;&lt; &lt;&lt; "i is an occurance";
  }
}
</pre>
  <p>Этот алгоритм работает за произведение длины строки на длину подстроки. Похожая реализация есть в языке C++ в методе строки t.find(p), которая работает также за O(nm). Этот алгоритм не требует дополнительной памяти и на обычных данных работает быстрее чем более эффективная реализация.</p>

  <h4>Определение z-функции</h4>
  <p>Для заданной строки s = s0s1...s(n-1) ее z-функцией является массив z длины n. Где z[i] это длина наидлиннейшего общего префикса всей строки s и ее суффикса s[i ... n-1]. Для i=0 обычно z[0]=0 (но иногда удобно считать, что z[0]=n).</p>

  <h4>Пример</h4>
  <p>Дана строка s = "abacaba". Найти ее z-функцию.</p>
  <ul>
    <li>z[0] = 0</li>
    <li>z[1] = 0</li>
    <li>z[2] = 1</li>
    <li>z[3] = 0</li>
    <li>z[4] = 3</li>
    <li>z[5] = 0</li>
    <li>z[6] = 1</li>
  </ul>

  <h4>Z-алгоритм</h4>
  <p>Алгоритм нахождения z-функции строки за линейное время</p>
  <ol>
    <li>Будем вычислять значение z[i] слева направо, начиная с i=1</li>
    <li>Будем поддерживать такие два индекса l и r, что s[l ... r] - это префикс строки s, а значение r - максимально</li>
    <li>В частности, это означает, что
      <code>s[l] = s[0], s[l+1] = s[1], ... , s[i] = s[i-l], ... , s[r] = s[r-l]</code>
    </li>
    <li>Если i ≤ r, то пусть i' = i-l, посмотрим на z[i'] - это значение поможет найти z[i]</li>
    <li>По определению z[i'] верно:
      <code>s[0] = s[i'], s[1] = s[i'+1], ... , s[z[i']-1] = s[i' + z[i']-1]</code>
      <p>но помним, что</p>
      <code>s[i'] = s[i], s[i'+1] = s[i+1], ... , s[r-l] = s[r]</code>
      <p>Следовательно, s[0] = s[i], s[1] = s[i+1], ... и так далее всего min(z[i'], r-i+1) раз. То есть z[i] частично посчитана (z[i] ≥ min(z[i'], r-i+1)</p>
    </li>
  </ol>
</article>
