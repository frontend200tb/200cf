<article class="article">
  <strong>EDU ITMO пилотный курс. Михаил Мирзаянов</strong>
  <p>Это пилотный курс по спортивному программированию, чтобы проверить какой формат будет наиболее удобным и полезным. Курс будет содержать набор занятий по разными темам, связанным со спортивным программированием. Занятия подготовлены преподавателями Университета ИТМО.</p>
  <p>Мы будем постепенно добавлять новые занятия в этот курс и ждем от вас фидбек: что понравилось, чего не хватает, что можно сделать лучше. Приятного прохождения курса!</p>
</article>


<article class="article">
  <h1>1 Z-функция строки</h1>
  <p><a href="https://codeforces.com/group/kjV5ruxRwB/contest/634575" target="_blank">Codeforces Контест 634575</a></p>
  <p>(личная, ioi)</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#t1.1">1.1 Z-функция строки</a>
  <br><a href="#t1.2">1.2 Определение Z-функции</a>
  <br><a href="#t1.3">1.3 Z-алгоритм</a>
  <br><a href="#t1.4">1.4 Использование Z-функции для поиска вхождений</a>
</article>


<!-- 1.1 Z-функция строки -->
<article class="article">
  <div class="anchor" id="t1.1"></div>
  <h3>1.1 Z-функция строки</h3>

  <p>Это занятие посвящено одной из базовых тем stringology - z-функции строки. Эта тема не требует предварительных навыков, кроме базовой техники программирования.</p>

  <h4>Определения</h4>
  <p><strong>Строка</strong> - это конечная (возможно, пустая) последовательность символов. Длина строки s обозначается как |s| мощность множества. Символы строки нумеруются от 0 до s-1.</p>
  <p><strong>Алфавит строки</strong> - это все возможные символы строки.</p>
  <p><strong>Подстрока</strong> - последовательность подряд идущих символов строки. Подстрока задается ее позицией внутри строки от i до j. Длина подстроки равна j-i+1.</p>
  <p><strong>string</strong> строка. <strong>row</strong> строка в матрице. <strong>line</strong> строка в текстовом файле.</p>
  <p><strong>Вхождением</strong> строки p в строку t называют такую пару индексов (i,j), что p=t[i...j].</p>
  <p><strong>Префикс</strong> - это подстрока, которая начинается с начала строки. Всего у строки s+1 префиксов, пустой и полный тоже учитываются.</p>
  <p><strong>Суффикс</strong> - это подстрока, которая заканчивается концом строки. Всего у строки s+1 суффиксов, пустой и полный тоже учитываются.</p>
  <p><strong>Собственный префикс и собственный суффикс</strong> это не пустой и не совпадающий со строкой префикс и суффикс.</p>

  <h4>Поиск подстроки в строке</h4>
  <p>Основная задача stringology: string searching problem или string matching problem.</p>
  <p>Задана строка t (text) и строка p (pattern). Найдите все вхождения строки p в строку t.</p>
  <p>Если n=|t| и m=|p|, то наивный алгоритм полного перебора работает за время O(nm).</p>
<pre>
for (int i = 0; i &lt; n - m; i++) {
  mismatch = false;
  for (int k = 0; k &lt; m - 1; k++) {
    if (p[k] != t[i+k]) {
      mismatch = true;
      break;
    }
  }

  if (!mismatch) {
    cout &lt;&lt; "i is an occurance";
  }
}
</pre>
  <p>Этот алгоритм работает за произведение длины строки на длину подстроки. Похожая реализация есть в языке C++ в методе строки t.find(p), которая работает также за O(nm). Этот алгоритм не требует дополнительной памяти и на обычных данных работает быстрее чем более эффективная реализация.</p>
</article>


<!-- 1.2 Определение z-функции -->
<article class="article">
  <div class="anchor" id="t1.2"></div>
  <h3>1.2 Определение z-функции</h3>

  <p>Для заданной строки s = s0s1...s(n-1) ее z-функцией является массив z длины n. Где z[i] это длина наидлиннейшего общего префикса всей строки s и ее суффикса s[i ... n-1]. Для i=0 обычно z[0]=0 (но иногда удобно считать, что z[0]=n).</p>

  <h4>Пример</h4>
  <p>Дана строка s = "abacaba". Найти ее z-функцию.</p>
  <ul>
    <li>z[0] = 0</li>
    <li>z[1] = 0</li>
    <li>z[2] = 1</li>
    <li>z[3] = 0</li>
    <li>z[4] = 3</li>
    <li>z[5] = 0</li>
    <li>z[6] = 1</li>
  </ul>

  <h4>Примеры z-функции</h4>
  <code>s = "abacaba", z = [0,0,1,0,3,0,1]</code>
  <code>s = "aaaaaaaa", z = [0,7,6,5,4,3,2,1]</code>
  <code>s = "abababab", z = [0,0,6,0,4,0,2,0]</code>

  <h4>Упражнения</h4>
  <p>Найдите z-функцию строки s = "abaababa"</p>
  <details>
    <summary>Решение</summary>
    <p>z = [0,0,1,3,0,3,0,1]</p>
  </details>

    <p>Найдите z-функцию строки s = "baababaab"</p>
  <details>
    <summary>Решение</summary>
    <p>z = [0,0,0,2,0,4,0,0,1]</p>
  </details>

  <h4>z-функция: наивный алгоритм</h4>
  <p>Разработайет и реализуйте простой наивный (квадратичный) алгоритм для нахождения z-функции строки.</p>
  <details>
    <summary>Решение</summary>
    <p>Через цикл for</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  const n = 8;
  string s = "abaababa";
  int z[n] = {};

  z[0] = 0;

  for (int i = 1; i &lt; n; i++) {
    for (int j = i; j &lt; n; j++) {
      if (s[j] == s[j-i]) {
        z[i] += 1;
      } else {
        break;
      }
    }
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; z[i] &lt;&lt; ' ';
  }
}
</pre>

  <p>Через цикл while</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  const n = 8;
  string s = "abaababa";
  int z[n] = {};

  z[0] = 0;

  for (int i = 1; i &lt; n; i++) {
    while ((z[i] + i &lt; n) && (s[z[i] + i] == s[z[i]])) {
      z[i]++;
    }
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; z[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>

  <h4>Использование z-функции для поиска вхождений</h4>
  <p>Предположим, что умеем находить z-функцию эффективно. Тогда и задачу о нахождении подстроки в строке можно решить эффективно.</p>
  <p>Пусть дан текст t и образец p. Требуется найти все вхождения образца p в текст t.</p>
  <p>Построим новую строку s следующим образом: s = p + '$' + t, где $ это такой символ, которого нет ни в t ни в p.</p>
  <code>t = "aabaababaa"</code>
  <code>p = "abaa"</code>
  <code>s = "abaa$aabaababaa"</code>
  <p>Найдем z-функцию строки s</p>
  <code>z = {0,0,1,1,0,1,4,0,1,3,0,4,0,1,1}</code>
  <p>Значения z-функции строки s не могут быть больше чем длина строки p. Потому что после строки p стоит символ разделитель, который не встречается ни в строке p ни в строке t.</p>
  <p>Посмотрем на такие индексы, где значение z-функции точно равно 4, то есть длине образца. Это означает, что подстроки в строке s, которые начинаютмя с этих индексов совпадают с образцом.</p>
  <p>Если z[i] = |p|, то подстрока длины |p|, которая начинается в i совпадает с первыми |p| символами s, то есть она равна p. Следовательно, есть вхождение p в t с позиции i - |p| - 1.</p>

  <p>Алгоритм поиска подстроки в строке с помощью z-функции:</p>
  <ol>
    <li>Построим новую строку s = p + '$' + t</li>
    <li>Найдем z-функцию строки s</li>
    <li>z[i] = |p| тогда и только тогда, когда в t есть вхождение p с позиции i - |p| - 1</li>
  </ol>
</article>


<!-- 1.3 Z-алгоритм -->
<article class="article">
  <div class="anchor" id="t1.3"></div>
  <h3>1.3 Z-алгоритм</h3>

  <h4>Z-алгоритм</h4>
  <p>Алгоритм нахождения z-функции строки за линейное время</p>
  <ol>
    <li>Будем вычислять значение z[i] слева направо, начиная с i=1</li>
    <li>Будем поддерживать такие два индекса l и r, что s[l ... r] - это префикс строки s, а значение r - максимально</li>
    <li>В частности, это означает, что
<pre>
s[l] = s[0],
s[l+1] = s[1],
... ,
s[i] = s[i-l],
... ,
s[r] = s[r-l]
</pre>
    </li>
    <li>Попробуем воспользоваться предыдущими вычисленными значениями, чтобы сократить количество вычислений. Рассмотрим случай, когда i ≤ r это означает, что i находится между l и r. Если i ≤ r, то пусть i' = i-l, посмотрим на z[i'] - это значение поможет найти z[i]</li>
    <li>По определению z[i'] верно:
<pre>
s[0] = s[i'],
s[1] = s[i'+1],
... ,
s[z[i']-1] = s[i' + z[i']-1]
</pre>
      <p>но помним, что</p>
      <code>s[i'] = s[i], s[i'+1] = s[i+1], ... , s[r-l] = s[r]</code>
      <p>Следовательно, s[0] = s[i], s[1] = s[i+1], ... и так далее всего min(z[i'], r-i+1) раз. То есть z[i] частично посчитана (z[i] ≥ min(z[i'], r-i+1)</p>
    </li>
  </ol>

  <p>Рассмотрим несколько примеров, когда мы можем применять вычесленные значения z-функции для текущего z[i].</p>

  <h4>Случай 1.1</h4>
  <p>Предположим i ≤ r, то есть i принадлежит [l,r]. Тогда</p>
<pre>
s[i] = s[i-l],
s[i+1] = s[i-l+1],
... ,
s[r]=s[r-l]
</pre>
  <p>Пусть i' = i - l в некотором смысле отражение символа i в обработанной ранее части строки.</p>
<pre>
i = 0 1 2 3 4 5 6 7 8 9 10 11
s = a b a b c c a b a b  c  d
z = 0 0 2 0 0 0 5 0 ?
</pre>
  <p>Видим, что подстроки [0, 4] и [6, 10] совпадают</p>

  <h4>Случай 1.2</h4>
  <p>Предположим i ≤ r, то есть i принадлежит [l,r]. Тогда</p>
<pre>
s[i] = s[i-l],
s[i+1] = s[i-l+1],
... ,
s[r]=s[r-l]
</pre>
  <p>Пусть i' = i - l в некотором смысле отражение символа i в обработанной ранее части строки.</p>
<pre>
i = 0 1 2 3 4 5 6 7
s = a a a b a a a a
z = 0 2 1 0 3 ?
</pre>
<pre>
i = 0 1 2 3 4 5 6 7 8 9 10 11 12 13
s = a b a b a b a c a b  a  b  a  d
z = 0 0 5 0 3 0 1 0 5 0  ?
</pre>

  <h4>Случай 2</h4>
  <p>Предположим i > r, тогда предыдущие вычисленные значения z использовать нельзя.</p>
  <code>s = 0 ... r-l ... l ... r ... i ...</code>
  <p>В этом случае будем увеличивать z[i] начиная со значения 0 наивным образом (пока можно).</p>

  <h4>Z-алгоритм</h4>
  <ol>
    <li>Будем вычислять значение z[i] слева направо, начиная с i = 1</li>
    <li>Будем поддерживать такие два индекса l и r, что [l ... r] - это префикс строки s, а значение r  максимально.</li>
    <li>В частности, это означает, что
<pre>
s[l] = s[0],
s[l+1] = s[1],
... ,
s[r] = s[r-l]
</pre>
    </li>
    <li>Если i ≤ r, то посмотрим на z[i-l] - это значение поможет найти z[i]
      <ul>
        <li>В самом деле подстроки длины r-i+1, которые начинаются в i и i-l равны</li>
        <li>Если z[i-l] &lt; r-i+1, то тогда и z[i] = z[i-l]. В этом случае значение z[i] подсчитано.</li>
        <li>Если z[i-l] ≥ r-i+1, то z[i] точно больше или равно r-i+1, то точное значение неизвестно. Наивным способом будет увеличивать z[i] пока можно, получим точное значеиние.</li>
      </ul>
    </li>
    <li>Если i &gt; r, то доп. информации для z[i] нет и будем вычислять z[i] наивно.</li>
    <li>Заметим, что подстрока длины s[i ... (i + z[i] - 1)] совпадает с префиксом и пара индексов i и (i + z[i] - 1) это кандидаты в индексы l и r. Пересчитаем l и r, если нужно (то есть, если r &lt; (i + z[i] - 1))</li>
  </ol>
  <p>Напишем код в точности по этому алгоритму, а затем оптимизируем его.</p>
<pre>
int n = s.size(); // длина строки
int l = 0;
int r = 0;

for (int i = 1; i &lt; n; i++) {

  // возможно только 2 случая
  if (r >= i) {
    // 1 случай, когда r >= i
    // можем ли воспользоваться [l,r] блоком?
    if (z[i-l &lt; r-i+1]) { // значение z[i-l] короче правого конца?
      z[i] = z[i-l];
    } else {
      z[i] = r - i + 1; // совпадение до правого конца или дальше
      while (z[i]+i &lt; n && s[z[i]] == s[z[i] + i]) {
        z[i]++;
      }
    }
  } else {
    // 2 случай, когда i > r
    while (z[i]+i &lt; n && s[z[i]] == s[z[i]+i]) {
      z[i]++;
    }
  }

  if (r &lt; i+z[i]-1) {
    // обновляем l и r
    // пересчитаем [l,r], поддерживаем максимальный r
    l = i;
    r = i + z[i] - 1;
  }
}
</pre>
  <p>Заметим, что цикл while можно выполнять в конце каждого из двух случаев, при этом если он не нужен, то он и не будет выполняться. Поэтому вынесем его и if и else, таким образом избавимся от else. Напишем оптимальный алгоритм</p>
<pre>
int n = s.size(); // длина строки
int l = 0;
int r = 0;

for (int i = 1; i &lt; n; i++) {

  if (r >= i) {
    z[i] = min(z[i-l], r-i+1);
  }

  while (z[i]+i &lt; n && s[z[i]] == s[z[i] + i]) {
    z[i]++;
  }

  if (i+z[i]-1 > r) {
    l = i;
    r = i + z[i] - 1;
  }
}
</pre>
  <ol>
    <li>Работает за O(n) потому что при каждом увеличении z[i] внутри while индекс r тоже сдвигается право. Сдвинутся более n раз он не может.</li>
    <li>Можно сократить реализацию, если правую границу делать не включительно, то есть использовать интервал [l,r).</li>
  </ol>
</article>


<!-- 1.4 Использование Z-функции для поиска вхождений -->
<article class="article">
  <div class="anchor" id="t1.4"></div>
  <h3>1.4 Использование Z-функции для поиска вхождений</h3>

  <h4>Поиск подстроки в строке</h4>
  <p>Пусть дан текст t и образец p. Требуется найти все вхождения образца p в текст t.</p>
  <ol>
    <li>Построим строку s = p + '$' + t</li>
    <li>Найдем z-функцию строки s</li>
    <li>z[i] = p.size() тогда и только тогда, когда в t есть вхождение p с позиции i - p.size() - 1</li>
  </ol>

  <h4>Задача</h4>
  <p>Заданы две строки s и t. Надо проверить является t цикличесим сдвигом строки s. Например, для abcd ее циклические сдвиги: abcd, bcda, cdab и dabc.</p>
  <p>Циклический сдвиг это операция переноса первого символа строки в конец строки.</p>

  <details>
    <summary>Решение</summary>
    <p>Запишем строку s два раза подряд. В получившейся строке нйдем t как подстроку.</p>
<pre>
s = abcd;
t = cdab;
ss = abcdabcd
</pre>
    <p>Если строка t найдена, то она является циклическим сдвигом строки s. Иначе не является.</p>
  </details>

  <h3>Z-функция: наибольшая грань строки</h3>

  <p>Гранью строки называется каждый ее такой собственный префикс, который одновременно является и ее суффиксом. Собственный префикс (суффикс) - это префикс (суффикс) отличный от самой строки.</p>
  <p>Например, гранями строки s = "abacaba" являются три строки "", "a", "aba".</p>

  <h4>Задача</h4>
  <p>Задана строка s. Найдите ее самую длинную грань. Например, для s = "abacaba" надо вернуть "aba".</p>

  <details>
    <summary>Решение</summary>
    <p>Для нахождения наибольшей грани с помощью z-функции достаточно найти наименьшее i, что i+z[i] = |s|. Тогда соответствующее z[i] - это наидлиннейшая грань строки s.</p>
  </details>

  <h3>Z-функция: количество различных подстрок за O(n<sup>2</sup>)</h3>

  <p>Задана строка s, выведите количество различных непустых подстрок в ней.</p>
  <p>Например, если s = "abaaba", то все ее различные подстроки - это a, aa, aab, aaba, ab, aba, abaa, abaab, abaaba, b, ba, baa, baab, baaba. Всего 14 штук.</p>
  <p>Начнем с пустой строки t и будем набирать строку s справа налево (каждый раз дописывая к t слева очередной символ: t = s[i]+t), пока не дойдем до полной строки t = s.</p>
  <p>В ходе этого будем поддерживать ответ - количество различных подстрок для текущей строки t.</p>
  <code>a      +1:  a</code>
  <code>ba     +2:  b, ba</code>
  <code>aba    +2:  ab, aba</code>
  <code>aaba   +3:  aa, aab, aaba</code>
  <code>baaba  +3:  baa, baab, baaba</code>
  <code>abaaba +3:  abaa, abaab, abaaba</code>
  <p>Рассмотрим как происходит переход от более короткого суффикса к суффиксу, который на один символ длинее.</p>
  <p>Каждый раз к ответу добавляются новые префиксы строки t. То есть такие префиксы, которые не были добавлены ранее. То есть такие префиксы, которые не встречаются далее в t.</p>
  <p>Добавляются такие префиксы t, которые длиннее самого длинного префикса, который встречается правее.</p>

  <h4>Подзадача</h4>
  <p>В строке t найти длину даидлиннейшего префикса, который встречается еще хобя бы раз в t.</p>

  <details>
    <summary>Решение</summary>
    <p>Найдем z-функцию строки t, тогда максимум из значений в ней - это искомая длина наиболее длинного префикса, который встречается в t как не-префикс. Тогда каждый раз к ответу прибавляется |t|-max{z(t)}</p>
  </details>

  <h4>Алгоритм решения задачи о нахождении различных подстрок</h4>
  <ol>
    <li>Ответ накапливаем в виде суммы sum, которая изначально равна нулю</li>
    <li>Будем перебирать все суффиксы строки s, начиная от суффикса t = "", заканчивая суффиксом t = s.</li>
    <li>Пусть текущий суффикс это строка t = s[i] + t. Для строки t найдем ее z-функцию.</li>
    <li>Увеличим ответ на i+1-max{z(t)}, так как |t|=i+1</li>
  </ol>
  <p>Всего O(n) шагов, каждый шаг выполняется за линейное время. Итого, общее время работы алгоритма составляет O(n<sup>2</sup>).</p>

</article>
