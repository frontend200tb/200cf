<article class="article">
  <strong>EDU ITMO пилотный курс. Михаил Мирзаянов</strong>
  <p>Это пилотный курс по спортивному программированию, чтобы проверить какой формат будет наиболее удобным и полезным. Курс будет содержать набор занятий по разными темам, связанным со спортивным программированием. Занятия подготовлены преподавателями Университета ИТМО.</p>
  <p>Мы будем постепенно добавлять новые занятия в этот курс и ждем от вас фидбек: что понравилось, чего не хватает, что можно сделать лучше. Приятного прохождения курса!</p>
</article>


<article class="article">
  <h1>1 Z-функция строки</h1>
  <p><a href="https://codeforces.com/group/kjV5ruxRwB/contest/634575" target="_blank">Codeforces Контест 634575</a></p>
  <p>(личная, ioi)</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

      <a href="#t1">1 Z-функция строки</a>
</article>


<!-- 1 Z-функция строки -->
<article class="article">
  <div class="anchor" id="t1"></div>
  <h3>1 Z-функция строки</h3>

  <p>Это занятие посвящено одной из базовых тем stringology - z-функции строки. Эта тема не требует предварительных навыков, кроме базовой техники программирования.</p>

  <h4>Определения</h4>
  <p><strong>Строка</strong> - это конечная (возможно, пустая) последовательность символов. Длина строки s обозначается как |s| мощность множества. Символы строки нумеруются от 0 до s-1.</p>
  <p><strong>Алфавит строки</strong> - это все возможные символы строки.</p>
  <p><strong>Подстрока</strong> - последовательность подряд идущих символов строки. Подстрока задается ее позицией внутри строки от i до j. Длина подстроки равна j-i+1.</p>
  <p><strong>string</strong> строка. <strong>row</strong> строка в матрице. <strong>line</strong> строка в текстовом файле.</p>
  <p><strong>Вхождением</strong> строки p в строку t называют такую пару индексов (i,j), что p=t[i...j].</p>
  <p><strong>Префикс</strong> - это подстрока, которая начинается с начала строки. Всего у строки s+1 префиксов, пустой и полный тоже учитываются.</p>
  <p><strong>Суффикс</strong> - это подстрока, которая заканчивается концом строки. Всего у строки s+1 суффиксов, пустой и полный тоже учитываются.</p>
  <p><strong>Собственный префикс и собственный суффикс</strong> это не пустой и не совпадающий со строкой префикс и суффикс.</p>

  <h4>Поиск подстроки в строке</h4>
  <p>Основная задача stringology: string searching problem или string matching problem.</p>
  <p>Задана строка t (text) и строка p (pattern). Найдите все вхождения строки p в строку t.</p>
  <p>Если n=|t| и m=|p|, то наивный алгоритм полного перебора работает за время O(nm).</p>
<pre>
for (int i = 0; i &lt; n - m; i++) {
  mismatch = false;
  for (int k = 0; k &lt; m - 1; k++) {
    if (p[k] != t[i+k]) {
      mismatch = true;
      break;
    }
  }

  if (!mismatch) {
    cout &lt;&lt; "i is an occurance";
  }
}
</pre>
  <p>Этот алгоритм работает за произведение длины строки на длину подстроки. Похожая реализация есть в языке C++ в методе строки t.find(p), которая работает также за O(nm). Этот алгоритм не требует дополнительной памяти и на обычных данных работает быстрее чем более эффективная реализация.</p>

  <h4>Определение z-функции</h4>
  <p>Для заданной строки s = s0s1...s(n-1) ее z-функцией является массив z длины n. Где z[i] это длина наидлиннейшего общего префикса всей строки s и ее суффикса s[i ... n-1]. Для i=0 обычно z[0]=0 (но иногда удобно считать, что z[0]=n).</p>

  <h4>Пример</h4>
  <p>Дана строка s = "abacaba". Найти ее z-функцию.</p>
  <ul>
    <li>z[0] = 0</li>
    <li>z[1] = 0</li>
    <li>z[2] = 1</li>
    <li>z[3] = 0</li>
    <li>z[4] = 3</li>
    <li>z[5] = 0</li>
    <li>z[6] = 1</li>
  </ul>

  <h4>Примеры z-функции</h4>
  <code>s = "abacaba", z = [0,0,1,0,3,0,1]</code>
  <code>s = "aaaaaaaa", z = [0,7,6,5,4,3,2,1]</code>
  <code>s = "abababab", z = [0,0,6,0,4,0,2,0]</code>

  <h4>Упражнения</h4>
  <p>Найдите z-функцию строки s = "abaababa"</p>
  <details>
    <summary>Решение</summary>
    <p>z = [0,0,1,3,0,3,0,1]</p>
  </details>

    <p>Найдите z-функцию строки s = "baababaab"</p>
  <details>
    <summary>Решение</summary>
    <p>z = [0,0,0,2,0,4,0,0,1]</p>
  </details>

  <h4>z-функция: наивный алгоритм</h4>
  <p>Разработайет и реализуйте простой наивный (квадратичный) алгоритм для нахождения z-функции строки.</p>
  <details>
    <summary>Решение</summary>
    <p>Через цикл for</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  const n = 8;
  string s = "abaababa";
  int z[n] = {};

  z[0] = 0;

  for (int i = 1; i &lt; n; i++) {
    for (int j = i; j &lt; n; j++) {
      if (s[j] == s[j-i]) {
        z[i] += 1;
      } else {
        break;
      }
    }
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; z[i] &lt;&lt; ' ';
  }
}
</pre>

  <p>Через цикл while</p>
<pre>
#include &lt;iostream&gt;

using namespace std;

int main() {
  const n = 8;
  string s = "abaababa";
  int z[n] = {};

  z[0] = 0;

  for (int i = 1; i &lt; n; i++) {
    while ((z[i] + i &lt; n) && (s[z[i] + i] == s[z[i]])) {
      z[i]++;
    }
  }

  for (int i = 0; i &lt; n; i++) {
    cout &lt;&lt; z[i] &lt;&lt; ' ';
  }
}
</pre>
  </details>

  <h4>Использование z-функции для поиска вхождений</h4>
  <p>Предположим, что умеем находить z-функцию эффективно. Тогда и задачу о нахождении подстроки в строке можно решить эффективно.</p>
  <p>Пусть дан текст t и образец p. Требуется найти все вхождения образца p в текст t.</p>
  <p>Построим новую строку s следующим образом: s = p + '$' + t, где $ это такой символ, которого нет ни в t ни в p.</p>
  <code>t = "aabaababaa"</code>
  <code>p = "abaa"</code>
  <code>s = "abaa$aabaababaa"</code>
  <p>Найдем z-функцию строки s</p>
  <code>z = {0,0,1,1,0,1,4,0,1,3,0,4,0,1,1}</code>
  <p>Значения z-функции строки s не могут быть больше чем длина строки p. Потому что после строки p стоит символ разделитель, который не встречается ни в строке p ни в строке t.</p>
  <p>Посмотрем на такие индексы, где значение z-функции точно равно 4, то есть длине образца. Это означает, что подстроки в строке s, которые начинаютмя с этих индексов совпадают с образцом.</p>
  <p>Если z[i] = |p|, то подстрока длины |p|, которая начинается в i совпадает с первыми |p| символами s, то есть она равна p. Следовательно, есть вхождение p в t с позиции i - |p| - 1.</p>

  <p>Алгоритм поиска подстроки в строке с помощью z-функции:</p>
  <ol>
    <li>Построим новую строку s = p + '$' + t</li>
    <li>Найдем z-функцию строки s</li>
    <li>z[i] = |p| тогда и только тогда, когда в t есть вхождение p с позиции i - |p| - 1</li>
  </ol>

  <h4>Z-алгоритм</h4>
  <p>Алгоритм нахождения z-функции строки за линейное время</p>
  <ol>
    <li>Будем вычислять значение z[i] слева направо, начиная с i=1</li>
    <li>Будем поддерживать такие два индекса l и r, что s[l ... r] - это префикс строки s, а значение r - максимально</li>
    <li>В частности, это означает, что
<pre>
s[l] = s[0],
s[l+1] = s[1],
... ,
s[i] = s[i-l],
... ,
s[r] = s[r-l]
</pre>
    </li>
    <li>Попробуем воспользоваться предыдущими вычисленными значениями, чтобы сократить количество вычислений. Рассмотрим случай, когда i ≤ r это означает, что i находится между l и r. Если i ≤ r, то пусть i' = i-l, посмотрим на z[i'] - это значение поможет найти z[i]</li>
    <li>По определению z[i'] верно:
<pre>
s[0] = s[i'],
s[1] = s[i'+1],
... ,
s[z[i']-1] = s[i' + z[i']-1]
</pre>
      <p>но помним, что</p>
      <code>s[i'] = s[i], s[i'+1] = s[i+1], ... , s[r-l] = s[r]</code>
      <p>Следовательно, s[0] = s[i], s[1] = s[i+1], ... и так далее всего min(z[i'], r-i+1) раз. То есть z[i] частично посчитана (z[i] ≥ min(z[i'], r-i+1)</p>
    </li>
  </ol>

  <p>Рассмотрим несколько примеров, когда мы можем применять вычесленные значения z-функции для текущего z[i].</p>

  <h4>Случай 1.1</h4>
  <p>Предположим i ≤ r, то есть i принадлежит [l,r]. Тогда</p>
<pre>
s[i] = s[i-l],
s[i+1] = s[i-l+1],
... ,
s[r]=s[r-l]
</pre>
  <p>Пусть i' = i - l в некотором смысле отражение символа i в обработанной ранее части строки.</p>
<pre>
i = 0 1 2 3 4 5 6 7 8 9 10 11
s = a b a b c c a b a b  c  d
z = 0 0 2 0 0 0 5 0 ?
</pre>
  <p>Видим, что подстроки [0, 4] и [6, 10] совпадают</p>

  <h4>Случай 1.2</h4>
  <p>Предположим i ≤ r, то есть i принадлежит [l,r]. Тогда</p>
<pre>
s[i] = s[i-l],
s[i+1] = s[i-l+1],
... ,
s[r]=s[r-l]
</pre>
  <p>Пусть i' = i - l в некотором смысле отражение символа i в обработанной ранее части строки.</p>
<pre>
i = 0 1 2 3 4 5 6 7
s = a a a b a a a a
z = 0 2 1 0 3 ?
</pre>
<pre>
i = 0 1 2 3 4 5 6 7 8 9 10 11 12 13
s = a b a b a b a c a b  a  b  a  d
z = 0 0 5 0 3 0 1 0 5 0  ?
</pre>

  <h4>Случай 2</h4>
  <p>Предположим i > r, тогда предыдущие вычисленные значения z использовать нельзя.</p>
  <code>s = 0 ... r-l ... l ... r ... i ...</code>
  <p>В этом случае будем увеличивать z[i] начиная со значения 0 наивным образом (пока можно).</p>

  <h4>Z-алгоритм</h4>
  <ol>
    <li>Будем вычислять значение z[i] слева направо, начиная с i = 1</li>
    <li>Будем поддерживать такие два индекса l и r, что [l ... r] - это префикс строки s, а значение r  максимально.</li>
    <li>В частности, это означает, что
<pre>
s[l] = s[0],
s[l+1] = s[1],
... ,
s[r] = s[r-l]
</pre>
    </li>
    <li>Если i ≤ r, то посмотрим на z[i-l] - это значение поможет найти z[i]
      <ul>
        <li>В самом деле подстроки длины r-i+1, которые начинаются в i и i-l равны</li>
        <li>Если z[i-l] &lt; r-i+1, то тогда и z[i] = z[i-l]. В этом случае значение z[i] подсчитано.</li>
        <li>Если z[i-l] ≥ r-i+1, то z[i] точно больше или равно r-i+1, то точное значение неизвестно. Наивным способом будет увеличивать z[i] пока можно, получим точное значеиние.</li>
      </ul>
    </li>
    <li>Если i &gt; r, то доп. пнйормации для z[i] нет и будем вычислять z[i] наивно.</li>
    <li>Заметим, что подстрока длмны s[i ... i + z[i] - 1 совпадает с префиксом, пересчитаем l и r, если нужно (то есть, если r &lt; i + z[i] - 1)</li>
  </ol>
</article>
