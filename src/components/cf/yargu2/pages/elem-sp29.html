<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 29. Структуры данных 3. bitset</h1>
  <p>Конспект видео</p>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contest/536304" target="_blank">Codeforces Контест 536304</a></p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p1">Структуры данных 3. bitset</a></p>
</article>


<!-- Структуры данных 3. bitset -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Структуры данных 3. bitset</h3>

  <p>Поговорим про сжатие информации. Первое что можно сказать, это что O(n<sup>3</sup>) при n = 1000 заходит за секунду. Компьютер способен обработать милиард операций за секунду. При кубической асимптотике нужно сразу смотреть на значение n. Если значение n не превышает 1000, то решение может зайти. Если не заходит, то может помочь сжатие данных.</p>
  <p>Над двумя целыми числами a и b можно выполнять побитовые операции</p>
  <code>a | b</code>
  <code>a & b</code>
  <code>a ^ b</code>

  <p>Пример</p>
<pre>
a = 5;      // 0101
b = 9;      // 1001
a | b = 13; // 1101
a & b = 1;  // 0001
a ^ b = 10; // 1100
</pre>

  <p>На соревнованиях стали чаще появляться задачи на xor и на mex. Операция mex не относится к битовым операциям. mex не является встроенной в язык C++, ее надо реализовать самому.</p>
  <p>mex последовательности это минимальное целое неотрицательное число, которое не встречается в последовательности.</p>

  <p>Пример</p>
  <code>A = {0, 1, 1, 3, 5};</code>
  <code>mex(A) = 2;</code>

  <h4>Операция битовый сдвиг влево</h4>
  <p>Битовый сдвиг влево аналогичен умножению на степень двойки</p>
  <code>a &lt;&lt; b = a * 2<sup>b</sup></code>

  <h4>Операция битовый сдвиг вправо</h4>
  <p>Битовый сдвиг вправо аналогичен делению на степень двойки</p>
  <code>a &lt;&lt; b = a / 2<sup>b</sup></code>

  <h4>Битовая маска</h4>
  <p>Пусть есть n предметов и каждый предмет имеет свой вес a1, a2, ..., an. Есть 2 способа перебрать этот массив:</p>
  <p>1. Рекурсия</p>
  <p>2. Битовая маска</p>
<pre>
for (int mask = 0; mask &lt; (1 &lt;&lt; n); mask++) {

}
</pre>
  <p>Поскольку число масок получится 2<sup>n</sup>, то решение подходит только для n ≤ 25.</p>

  <h4>Подмаска</h4>
  <p>Для маски mask подмаской является любое значение x для которого x & mask = x.</p>

  <p>Задача. Друзья по коду</p>
  <p>Есть 1000 задач, которые решают студенты. Для каждого студента заведем массив на 1000 элементов, где номер элемента это задача, значение 0 означает что задача не решена, значение 1 означает что задача решена. Если между двумя студентами совпадает больше чем k задач, то они друзья. Чтобы найти все пары друзей, нужно их всех перебрать за O(n<sup>2</sup>*m)</p>
  <p>Компьютер сравнивает две булевые переменные и две целочисленные переменные за одинаковое время. Это связано с тем что 32 битный процессор работает одновременно со всеми битами целого числа и сравнивает все биты сразу. 64 битный процессор сравнивает переменные типа long long за то же время что и два разряда.</p>
  <p>Разобьем наш массив из 1000 элементов (с ноликами и единицами) на блоки размером z. Пусть z = 20, тогда можно представить значение каждого блока (из ноликов и единиц) как целое число (не превосходящее 2<sup>20</sup>). Теперь можно делать сравнение не каждого разряда, а каждого блока размером z. Такое решение будет иметь асимптотику O(n<sup>2</sup>*m / z).</p>

  <h4>Создание bitset</h4>
  <p>Размер битсета можно задать только статической константой, которая известна заранее на этапе компиляции. </p>
<pre>
const int len = 1000;
bitset&lt;len&gt; b;
bitset&lt;len&gt; c;
</pre>

  <h4>Операции с bitset</h4>
  <p>Если создать два битсета одинаковой длины, то можно с ними производить простейшие операции.</p>
<pre>
b | c
b & c
b ^ c
b &lt;&lt; c
b &gt;&gt; c
</pre>

  <h4>Методы bitset</h4>
  <ol>
    <li>b.set() устанавливает все биты в 1</li>
    <li>b.reset() устанавливает все биты в 0</li>
    <li>b.flip() инвертировать все биты</li>
    <li>b.count() вернет число единиц в битсете</li>
    <li>b[i] вернет значение i-го бита</li>
  </ol>

  <h4>Задача. Рюкзак</h4>
  <p>Есть n предметов, каждый предмет имеет свой вес w1, w2, ..., wn. Есть рюкзак, в который можно положить суммарный вес не более s. Нужно заполнить рюкзак максимальным весом предметов. n ≤ 10<sup>5</sup>, s ≤ 10<sup>5</sup>.</p>

  <p>При таких условиях и ограничениях задачу можно решить при помощи bitset. Создадим матрицу Dp, где Dp[i][j] = 0 означает что нельзя собрать вес j используя i предметов, Dp[i][j] = 1 означает что можно собрать вес j используя i предметов.</p>
  <p>Когда соберем всю матрицу Dp, ответ будет в ячейке dp[n][s].</p>
</article>
