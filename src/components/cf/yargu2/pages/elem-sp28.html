<article class="article">
  <strong>Спортивное программирование в ЯрГУ</strong>
  <p><a href="https://codeforces.com/group/w0J26SHHez/contests" target="_blank">Codeforces ЯрГУ. Студенты</a></p>
  <p><a href="https://vk.com/yaracm" target="_blank">https://vk.com/yaracm</a></p>
  <p><a href="https://vkvideo.ru/@yaracm" target="_blank">vkvideo.ru/@yaracm</a></p>
</article>


<article class="article">
  <h1>Занятие 28. Дерево отрезков 2</h1>
  <p>Конспект видео</p>
</article>


<!-- Содержание -->
<article class="article">
  <h2>Содержание</h2>

  <p><a href="#p1">Дерево отрезков 2</a></p>

</article>


<!-- Дерево отрезков -->
<article class="article">
  <div class="anchor" id="p1"></div>
  <h3>Дерево отрезков</h3>

  <h4>Массовые операции</h4>

  <p>Изобразим дерево на поиск максимума</p>
<pre>
             9
         /      \
      4            9
    /  \          /  \
  3      4      9      6
 / \    / \    / \    / \
3   1  4   1  5   9  2   6
</pre>

  <p>Каждая вершина отвечает за определенный полуинтервал</p>
<pre>
                       9
                     [0,8)
                 /            \
           4                       9
         [0,4)                   [4,8)
       /       \              /        \
     3           4          9            6
   [0,2)       [2,4)      [4,6)        [6,8)
    / \         / \        / \          / \
  3     1     4     1    5      9     2     6
[0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8)
</pre>

  <h4>Теперь поработаем с деревом на поиск минимума</h4>
<pre>
                       1
                     [0,8)
                 /            \
           1                       2
         [0,4)                   [4,8)
       /       \              /        \
     1           1          5            2
   [0,2)       [2,4)      [4,6)        [6,8)
    / \         / \        / \          / \
  3     1     4     1    5      9     2     6
[0,1) [1,2) [2,3) [3,4) [4,5) [5,6) [6,7) [7,8)
</pre>

  <p>Мы умеем искать минимум на отрезке и умеем изменять одно значение.</p>
  <p>Научимся изменять все числа на отрезке, например, нужно ко всем числам на интервале [2,5) прибавить 3. Если делать изменения для каждой точки, то это будет долго, если отрезок будет слишком большой.</p>
  <p>Наш подход, который мы рассмотрим будет работать для дистрибутивных операций (максимум, минимум).</p>
  <p>Дистрибутивная операция</p>
  <code>min(a, b) + x = min(a + x, b + x)</code>
  <p>tr[v] - значение операции для отрезка [l, r)</p>

  <h4>Техника lazy propagation (ленивое проталкивание)</h4>
  <p>Пока в вершину не попали, в ней ничего не меняем.</p>
  <p>Рассмотрим отрезок [2,5), то есть для вершин 2, 3, 4 нужно поменять значения. Спустимся от корня вниз и увидим, что отрезок [2,5) представлен в двух вершинах [2,4) и [4,5). Чтобы внести в них изменения</p>
  <p>Рассмотрим отрезок [1,6), то есть для вершин 1,2,3,4,5 нужно поменять значения. Спустимся от корня вниз и увидим, что отрезок [1,6) представлен в трех вершинах [1,2), [2,4) и [4,6).</p>
  <p>add(v) - сколько прибавить на отрезке [l,r)</p>
  <p>Теперь все эти операции нужно реализовать. Построение дерева не изменится и будет точно таким же как раньше. Изменятся только две операции. Обновление на отрезке и минимальное значение на отрезке.</p>
<pre>
void update(v, l, r, lq, rq, val) {
  push(v, l, r); // проталкивание

  if () {
    // если отрезки не пересекаются
    return;
  }

  if () {
    // если отрезок полностью входит
    add[v] += val;
    return;
  } else {
    int m = (l + r) / 2;
    update(2v + 1, l, m, lq, lr, val);
    // идем в левого ребенка
    update(2v + 2, m, r, lq, lr, val);
    // идем в правого ребенка
    t[v] = min(t[2v+1], t[2v+2]);
    // записываем новый минимум
  }
}
</pre>

<pre>
int get(v, l, r, lq, rq) {
  push(v, l, r);

  if () {
    // если отрезки не пересекаются
    return -Inf;
  }

  if () {
    // если отрезок полностью входит
    return t[v];
  } else {
    int m = (l+r) / 2;
    min_l = get(v, l, m, lq, lr);
    // берем значение минимума в левом ребенке
    min_r = get(v, m, r, lq, lr);
    // берем значение минимума в правом ребенке
    return min(min_l, min_r);
    // возвращаем их минимум
  }
}
</pre>

<pre>
push(v, l, r) {
  // записываем накопившиеся изменения
  t[v] += add[v];

  // если эта вершина не лист
  if (r - l > 1) {
    // проталкиваем информацию в детей
    add[2v+1] += add[v];
    add[2v+2] += add[v];
  }
  обнулим изменения, поскольку мы их уже учли
  add[v] = 0;
}
</pre>

  <h4>Теперь поработаем с деревом на поиск суммы</h4>

  <p>В функции update нужно изменить только одну строчку, где в вершину мы будем записывать не новый минимум от ее детей, а новую сумму от ее детей.</p>
<pre>
void update(v, l, r, lq, rq, val) {
  push(v, l, r); // проталкивание

  if () {
    // если отрезки не пересекаются
    return;
  }

  if () {
    // если отрезок полностью входит
    add[v] += val;
    return;
  } else {
    int m = (l + r) / 2;
    update(2v + 1, l, m, lq, lr, val);
    // идем в левого ребенка
    update(2v + 2, m, r, lq, lr, val);
    // идем в правого ребенка
    t[v] = t[2v+1] + t[2v+2];
    // записываем новую сумму
  }
}
</pre>

  <p>В функции get изменим 4 строчки. Возвращать будем не -Inf, а 0. Из детей будем брать не значение минимума, а значение суммы</p>
<pre>
int get(v, l, r, lq, rq) {
  push(v, l, r);

  if () {
    // если отрезки не пересекаются
    return 0;
  }

  if () {
    // если отрезок полностью входит
    return t[v];
  } else {
    int m = (l+r) / 2;
    sum_l = get(v, l, m, lq, lr);
    // берем значение минимума в левом ребенке
    sum_r = get(v, m, r, lq, lr);
    // берем значение минимума в правом ребенке
    return sum_l + sum_r;
    // возвращаем их сумму
  }
}
</pre>

  <p>В функции push изменится одна строчка. В вершину нужно добавить не просто новое значение, а новое значение умножить на длину отрезка.</p>
<pre>
push(v, l, r) {
  // записываем накопившиеся изменения
  t[v] += add[v] * (r-l);

  // если эта вершина не лист
  if (r - l > 1) {
    // проталкиваем информацию в детей
    add[2v+1] += add[v];
    add[2v+2] += add[v];
  }
  обнулим изменения, поскольку мы их уже учли
  add[v] = 0;
}
</pre>

  <h4>Присвоение на отрезке</h4>

  <p>Пусть к нам приходят следующие запросы. Вычислить максимум на отрезке [l, r) и выполнить присвоение на отрезке.</p>
  <pre>
push(v, l, r) {
  // записываем накопившиеся изменения
  t[v] = add[v];

  // если эта вершина не лист
  if (r - l > 1) {
    // проталкиваем информацию в детей
    add[2v+1] = add[v];
    add[2v+2] = add[v];
  }
  обнулим изменения, поскольку мы их уже учли
  add[v] = 0;
}
</pre>

</article>
